<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>DMZ Simulator</title>
  <link rel='stylesheet' href="{{ url_for('static', filename='minesweeper.css') }}">
</head>

<body>
    <h1>Sweep Them Mines Boy</h1>
    <div class='legend'>Leftâ€‘click: reveal â€¢ Rightâ€‘click: ðŸš©</div>
    <div class='wrap'>
        <div class='controls'>
            <span id='nflags-base' class='counter'><span id='nflags'> </span></span>
            <button id='reset'>ðŸ™‚</button>
            <span id='timer-base' class='counter'><span id='timer'> </span></span>
        </div>
        <div id='grid' class='grid'></div>
    </div>
    <div class='scores'>
        <span id='score-base'>Score: <span id='score'> </span></span>
        <span id='hscore-base'>Best: <span id='hscore'> </span></span>
    </div>

    <script>
        // timer vars
        const max_time = 999 // secs
        let elapsed_t = 0
        let timer_id = null


        // --------------------- game logic --------------------------
        async function init() {
            const r = await fetch('/minesweeper/init', {method: 'GET'})
            const data = await r.json()
            
            await create_grid(data.ndim)
            await load_board_state(
                data.board, 
                data.revealed, 
                data.flagged, 
                data.mines, 
                data.finished
            )
            
            document.getElementById('nflags').textContent = `${data.nflags}`
            document.getElementById('reset').textContent = 'ðŸ™‚'
            document.getElementById('timer').textContent = String(0).padStart(3, '0')
            document.getElementById('score').textContent = `${data.score}`
            document.getElementById('hscore').textContent = `${data.hscore}`

            // if has been played for the day, in_progress remains true
            // so clicks have no response
            if (!data.played) {
                reset_timer()
            }
        }


        async function create_grid(ndim) {
            // update CSS variables for layout
            const grid = document.getElementById('grid')
            grid.style.setProperty('--cols', ndim)
            grid.innerHTML = ''
           
            // fill grid w/ buttons 
            for (let r=0; r<ndim; r++) {
                for (let c=0; c<ndim; c++) {
                    const tile = document.createElement('button')
                    tile.className = 'tile'
                    tile.dataset.row = r
                    tile.dataset.col = c
                    
                    // show coords on hover
                    tile.title = `(${r}, ${c})`
                    // left click: reveal
                    tile.addEventListener('click', async (e) => {
                        e.preventDefault()
                        await verify(tile)
                    });
                    // right click: flag
                    tile.addEventListener('contextmenu', async (e) => {
                        e.preventDefault()
                        await toggle_flag(tile)
                    });
                    
                    grid.appendChild(tile)
                }
            }
        }


        function load_board_state(board, revealed, flagged, mines, finished) {
            document.querySelectorAll('.tile').forEach(tile => {
                const r = Number(tile.dataset.row)
                const c = Number(tile.dataset.col)
                
                if (revealed[r][c])
                    reveal_tile(tile, board[r][c])
                else if (flagged[r][c])
                    tile.classList.toggle('flag')
            })

            if (finished)
                reveal_mines(mines)
        }
        

        async function verify(tile) {
            const i = Number(tile.dataset.row)
            const j = Number(tile.dataset.col)
            const r = await fetch('/minesweeper/verify', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({choice: [i,j]})
            })
            const data = await r.json()
            
            // if 1st tile to be clicked, start
            // start tile is always safe
            if (data.status == 'started') {
                start_timer()
                reveal_tiles(data.revealed)
                return
            }

            // do nothing if tile is flagged or game finished
            if (data.status == 'flagged' || data.status == 'finished')
                return
            if (data.status == 'continue') {
                reveal_tiles(data.revealed)
                return
            }
            // else, game finished
            stop_timer()
            update(data.score) 
            // if won, reveal tiles as usual
            if (data.status == 'won') {
                reveal_tiles(data.revealed)
                document.getElementById('reset').textContent = 'ðŸ˜Ž'
                return
            }
            // if over, reveal all mines unless correctly flagged
            reveal_mines(data.mines)
            document.getElementById('reset').textContent = 'ðŸ˜µ'
        }
        

        // tiles = {'r': int, 'c': int, 'num': int}
        // input already excludes revealed or flagged
        function reveal_tiles(tiles) {
            tiles.forEach(tile => {
                const tile_e = document.querySelector(`.tile[data-row="${tile.r}"][data-col="${tile.c}"]`)
                reveal_tile(tile_e, tile.num)
            })
        }
        

        function reveal_tile(tile_e, num) {
            tile_e.classList.add('reveal')
            // only show num if non-empty tile
            tile_e.textContent = num === 0 ? '' : num
            // assign preset colour to num
            if (num > 0) 
                tile_e.classList.add('num'+num)
        }


        function reveal_mines(mines) {
            mines.forEach(mine => {
                const e = document.querySelector(`.tile[data-row="${mine[0]}"][data-col="${mine[1]}"]`)
                // if already flagged, dont override w/ mine
                if (!e.classList.contains('flag')) {
                    e.textContent = 'ðŸ’£'
                    e.classList.add('reveal')
                }
            })
        }


        async function toggle_flag(tile) {
            // cant flag a revealed tile 
            if (tile.classList.contains('reveal')) 
                return

            // ensure indices are ints
            const i = Number(tile.dataset.row)
            const j = Number(tile.dataset.col)
            const r = await fetch('/minesweeper/flag', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({choice: [i, j]})
            })
            const data = await r.json()
            
            // only true if nflags = 0
            if (!data.toggle) return

            tile.classList.toggle('flag')
            document.getElementById('nflags').textContent = `${data.nflags}`
        }

        
        function update(score) {
            fetch('/minesweeper/update', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({score: score})
            })
            document.getElementById('score').textContent = `${score}`
        }
        
        
        // --------------------- timer ------------------------
        function start_timer() {
            // no dupes
            if (timer_id) return
            // incr elapsed time every 1000ms == 1s
            timer_id = setInterval(() => {
                elapsed_t++
                document.getElementById('timer').textContent = String(elapsed_t).padStart(3, '0')
                if (elapsed_t >= max_time) 
                    stop_timer()
            }, 1000)
        }

        function stop_timer() {
            if (!timer_id) return
            clearInterval(timer_id);
            timer_id = null
        }

        function reset_timer() {
            stop_timer()
            elapsed_t = 0
            document.getElementById('timer').textContent = String(0).padStart(3, '0')
        }
        
        
        // ------------------------ init -------------------------------
        window.onload = async function() {
            await init()
            //document.getElementById('reset').addEventListener('click', init)
        }

    </script>
</body>
</html>
