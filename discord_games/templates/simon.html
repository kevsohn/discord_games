<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Simon Says</title>
    <link rel='stylesheet' href="{{ url_for('static', filename='simon.css') }}">
</head>

<body>
    <h1>Simon Says...</h1>
    <div class='wrap'>
        <div id='status'> </div>
        <div id='squares'>
            <div class='colour' id='r' style='background: red;'></div>
            <div class='colour' id='g' style='background: green;'></div>
            <div class='colour' id='b' style='background: blue;'></div>
            <div class='colour' id='o' style='background: orange;'></div>
        </div>
        <button id='start'>Start</button>
        <div id='score-base'>Score: <span id='score'> </span></div>
        <div id='hscore-base'>High Score: <span id='hscore'> </span></div>
    </div>

    <script>
        // the class attribute is a group identifier and
        // querySelectorAll returns all elems as a NodeList
        const squares = document.querySelectorAll('.colour')
        // game params
        const flash_time = 200 // ms
        const wait_time = 800 // ms
        const rate_lim = 50 // ms
        let prev_click_time = 0 // ms


        async function init() {
            // urls on client-side need to have Blueprint prefix included
            const r = await fetch('/simon/init', {method: 'GET'})
            const data = await r.json()
            
            if (!data.played) {
                disable_squares()
                document.getElementById('start').disabled = false
                document.getElementById('status').textContent = 'Click "Start" to play!'
            }
            else {
                document.getElementById('start').disabled = true
                if (data.finished) {
                    disable_squares()
                    document.getElementById('status').textContent = 'Game Over...'
                }
                else { 
                    if (data.user_turn) {
                        enable_squares()
                        document.getElementById('status').textContent = 'Your turn!'
                    }
                    else
                        await show_sequence()
                }
            }

            document.getElementById('score').textContent = `${data.score}`
            document.getElementById('hscore').textContent = `${data.hscore}`
        }


        async function start() {
            fetch('/simon/start', {method: 'POST'})
            document.getElementById('start').disabled = true
            await show_sequence()
        }


        async function show_sequence() {
            disable_squares()
            document.getElementById('status').textContent = 'Watch closely...' 
            await new Promise(r => setTimeout(r, wait_time))
            
            const r = await fetch('/simon/get_sequence', {method: 'POST'})
            const data = await r.json()
            for (const colour of data.sequence) {
                await flash(colour)
                await new Promise(r => setTimeout(r, flash_time))
            }
            document.getElementById('status').textContent = 'Your turn!' 
            enable_squares()
        }


        // acts like a webhook by sending data to server at every event
        // attacker could modify data but it doesn't really matter bc
        // the server only accepts colours that it expects, and
        // you cant modify any of the state vars.
        // status: game_over, continue, next (turn)
        async function verify_choice(colour) {
            const now = Date.now()
            if (now - prev_click_time < rate_lim) return
            prev_click_time = now

            const r = await fetch('/simon/verify', {
                method: 'POST', 
                headers: {'Content-Type': 'application/json'}, 
                body: JSON.stringify({choice: colour})
            })
            const data = await r.json()

            if (data.status == 'game_over') {
                disable_squares()
                document.getElementById('status').textContent = 'Game Over...'
                document.getElementById('score').textContent = `${data.score}`
                document.getElementById('hscore').textContent = `${data.hscore}`
                return
            }
            if (data.status == 'continue') {
                document.getElementById('score').textContent = `${data.score}`
                await show_sequence()
                return
            }
        }


        // ------------------ helpers --------------------
        async function flash(colour) {
            const square = document.getElementById(colour)
            square.classList.add('flash')
            await new Promise(r => setTimeout(r, flash_time))
            square.classList.remove('flash')
        }


        function enable_squares() {
            squares.forEach(colour => colour.classList.add('on'))
        }


        function disable_squares() {
            squares.forEach(colour => colour.classList.remove('on'))
        }


        // ------------------  main ----------------------
        window.onload = async function() {
            await init()
        }
        
        document.getElementById('start').addEventListener('click', start)
        
        // forEach returns the element, not its id
        squares.forEach(colour => {
            // need to have async inside listener if fns are async
            colour.addEventListener('click', async () => {
                await flash(colour.id);
                await verify_choice(colour.id);
            })
        })
    </script>
</body>

